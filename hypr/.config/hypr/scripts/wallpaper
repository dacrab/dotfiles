#!/bin/bash

# =============================================================================
# WALLPAPER MANAGEMENT SCRIPT
# =============================================================================
# A unified script for managing wallpapers in Hyprland
# 
# Usage:
#   wallpaper cycle     - Cycle to the next wallpaper
#   wallpaper restore   - Restore the last wallpaper on startup
#   wallpaper list      - List available wallpapers
#   wallpaper current   - Show current wallpaper
#   wallpaper set <path> - Set a specific wallpaper
#
# Author: dacrab
# =============================================================================

# Configuration
readonly WALLPAPER_DIR="$HOME/Pictures/wallpapers/nord-background"
readonly LAST_WP_FILE="$HOME/.config/hypr/configs/last_wallpaper"
readonly SUPPORTED_FORMATS=("*.png" "*.jpg" "*.jpeg" "*.webp")
readonly MAX_ATTEMPTS=5
readonly HYPRPAPER_TIMEOUT=20

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'
# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
get_wallpapers() {
    find "$WALLPAPER_DIR" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) | sort
}

get_monitor() {
    local monitor
    monitor=$(hyprctl monitors | grep "Monitor" | head -n1 | cut -d' ' -f2 | tr -d '"')
    if [[ -z "$monitor" ]]; then
        monitor="HDMI-A-1"
        print_warning "Could not detect monitor, using fallback: $monitor"
    fi
    
    echo "$monitor"
}

wait_for_hyprpaper() {
    local attempt=0
    
    while (( attempt < HYPRPAPER_TIMEOUT )); do
        if hyprctl hyprpaper listactive &>/dev/null; then
            return 0
        fi
        ((attempt++))
        sleep 0.5
    done
    
    print_error "Timeout waiting for hyprpaper to be ready"
    return 1
}

generate_colors() {
    local wallpaper_path="$1"
    
    print_info "Generating Material You colors..."
    
    if matugen image "$wallpaper_path" --mode dark --type scheme-tonal-spot &>/dev/null; then
        print_success "Material You colors generated"
        
        # Update Starship colors if script exists
        local starship_script="$HOME/.config/hypr/scripts/generate_starship_colors"
        if [[ -x "$starship_script" ]] && "$starship_script" &>/dev/null; then
            print_success "Starship colors updated"
            fi
        
        # Reload Hyprland configuration
        if hyprctl reload &>/dev/null; then
            print_success "Hyprland configuration reloaded"
        fi
    else
        print_warning "Failed to generate Material You colors"
    fi
}

apply_wallpaper() {
    local wallpaper_path="$1"
    local monitor="$2"
    local attempt=0
    
    # Preload wallpaper
    hyprctl hyprpaper preload "$wallpaper_path" &>/dev/null
    
    # Set wallpaper with retry logic
    while (( attempt < MAX_ATTEMPTS )); do
        if hyprctl hyprpaper wallpaper "$monitor,$wallpaper_path" &>/dev/null; then
            generate_colors "$wallpaper_path"
            return 0
    fi
        ((attempt++))
        sleep 0.5
    done
    
    print_error "Failed to set wallpaper after $MAX_ATTEMPTS attempts"
        return 1
}

get_current_wallpaper() {
    hyprctl hyprpaper listactive 2>/dev/null | grep -o '/home.*' | head -n1
}

save_wallpaper() {
    local wallpaper_path="$1"
    echo "$wallpaper_path" > "$LAST_WP_FILE"
}
    
# =============================================================================
# WALLPAPER FUNCTIONS
# =============================================================================

cycle_wallpaper() {
    print_info "Cycling wallpaper..."
    
    local wallpapers
    mapfile -t wallpapers < <(get_wallpapers)
    
    if (( ${#wallpapers[@]} == 0 )); then
        print_error "No wallpapers found in $WALLPAPER_DIR"
        print_info "Supported formats: ${SUPPORTED_FORMATS[*]}"
        return 1
fi

    print_info "Found ${#wallpapers[@]} wallpapers"
    
    # Get current wallpaper
    local current_wp
    current_wp=$(get_current_wallpaper)
    
    if [[ -z "$current_wp" ]]; then
        if [[ -f "$LAST_WP_FILE" ]]; then
            current_wp=$(cat "$LAST_WP_FILE")
            print_info "Using last wallpaper: $(basename "$current_wp")"
        else
            current_wp="${wallpapers[0]}"
            print_info "Using first wallpaper: $(basename "$current_wp")"
        fi
    fi
    
    # Find next wallpaper
    local current_index=-1
    for i in "${!wallpapers[@]}"; do
        if [[ "${wallpapers[i]}" == "$current_wp" ]]; then
            current_index=$i
            break
        fi
    done
    
    local next_index=$(( (current_index + 1) % ${#wallpapers[@]} ))
    local next_wp="${wallpapers[$next_index]}"
    
    print_info "Cycling to: $(basename "$next_wp")"
    
    save_wallpaper "$next_wp"
    
    local monitor
    monitor=$(get_monitor)
    apply_wallpaper "$next_wp" "$monitor"
}

restore_wallpaper() {
    print_info "Restoring last wallpaper..."
    
    if ! wait_for_hyprpaper; then
        return 1
    fi
    
    if [[ ! -f "$LAST_WP_FILE" ]]; then
        print_warning "No last wallpaper file found"
        return 0
    fi
    
    local last_wp
    last_wp=$(cat "$LAST_WP_FILE")
    
    if [[ ! -f "$last_wp" ]]; then
        print_warning "Last wallpaper file does not exist: $last_wp"
        return 0
    fi
    
    print_info "Restoring: $(basename "$last_wp")"
    
    local monitor
    monitor=$(get_monitor)
    apply_wallpaper "$last_wp" "$monitor"
}

list_wallpapers() {
    print_info "Available wallpapers in $WALLPAPER_DIR:"
    echo
    local wallpapers
    mapfile -t wallpapers < <(get_wallpapers)
    
    if (( ${#wallpapers[@]} == 0 )); then
        print_warning "No wallpapers found"
        print_info "Supported formats: ${SUPPORTED_FORMATS[*]}"
        return 1
    fi
    
    for i in "${!wallpapers[@]}"; do
        echo "  $((i+1)). $(basename "${wallpapers[i]}")"
    done
    
    echo
    print_info "Total: ${#wallpapers[@]} wallpapers"
}

show_current() {
    local current_wp
    current_wp=$(get_current_wallpaper)
    
    if [[ -n "$current_wp" ]]; then
        print_info "Current wallpaper: $(basename "$current_wp")"
        echo "  Path: $current_wp"
    else
        print_warning "No wallpaper currently set"
    fi
}

set_specific_wallpaper() {
    local wallpaper_path="$1"
    
    if [[ -z "$wallpaper_path" ]]; then
        print_error "No wallpaper path provided"
        return 1
    fi
    
    if [[ ! -f "$wallpaper_path" ]]; then
        print_error "Wallpaper file does not exist: $wallpaper_path"
        return 1
    fi
    
    print_info "Setting wallpaper: $(basename "$wallpaper_path")"
    
    save_wallpaper "$wallpaper_path"
    
    local monitor
    monitor=$(get_monitor)
    apply_wallpaper "$wallpaper_path" "$monitor"
}

show_usage() {
    echo "Usage: $0 {cycle|restore|list|current|set <path>}"
    echo
    echo "Commands:"
    echo "  cycle      - Cycle to the next wallpaper"
    echo "  restore    - Restore the last wallpaper (for startup)"
    echo "  list       - List available wallpapers"
    echo "  current    - Show current wallpaper"
    echo "  set <path> - Set a specific wallpaper"
    echo
    echo "Configuration:"
    echo "  Wallpaper directory: $WALLPAPER_DIR"
    echo "  Last wallpaper file: $LAST_WP_FILE"
}

# =============================================================================
# MAIN SCRIPT
# =============================================================================

if (( $# == 0 )); then
    show_usage
        exit 1
fi

case "$1" in
    cycle)   cycle_wallpaper ;;
    restore) restore_wallpaper ;;
    list)    list_wallpapers ;;
    current) show_current ;;
    set)     set_specific_wallpaper "$2" ;;
    *)       print_error "Unknown command: $1"
             echo "Use '$0' to see available commands"
             exit 1 ;;
esac
